import java.io.*;
import java.util.*;

/**
 * ExperimentRunner - Runs the SM-CPTD paper experiments
 * Uses Pegasus workflows pre-generated by WfCommons
 *
 * Experiment 1: CCR effect (Figures 3-8)
 * - Small: 50 tasks with 5 VMs
 * - Medium: 100 tasks with 10 VMs
 * - Large: 1000 tasks with 50 VMs
 *
 * Experiment 2: Effect of VM count (Figures 9-10)
 * - 1000 tasks with variable VMs: 30, 35, 40, 45, 50, 55, 60, 65, 70
 * - Fixed CCR at 1.0
 *
 * Supported workflows (as shipped in this repo under workflow/):
 * - montage: astronomical image mosaic
 * - epigenomics: genome sequencing pipeline
 * - ligo: gravitational-wave data analysis
 * - cybershake: earthquake simulation workflow
 *
 * Metrics: SLR, AVU, VF
 */
public class ExperimentRunner {

    private static final int NUM_RUNS = 1;
    private static final int WARMUP_RUNS = 0;

    private static final String[] WORKFLOWS = { "cybershake", "epigenomics", "ligo", "montage" };
    private static final double[] CCR_VALUES = { 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0 };
    private static final int[] VM_COUNTS = { 30, 35, 40, 45, 50, 55, 60, 65, 70 };
    private static final double FIXED_CCR = 1.0;
    private static List<ExperimentResult> results = new ArrayList<>();

    public static class ExperimentResult {
        String experiment;
        String workflow;
        int numTasks;
        int numVMs;
        double ccr;
        double slr;
        double avu;
        double vf;
        double avgSatisfaction;
        double makespan;

        public ExperimentResult(String experiment, String workflow, int numTasks, int numVMs,
                double ccr, double slr, double avu, double vf, double avgSatisfaction, double makespan) {
            this.experiment = experiment;
            this.workflow = workflow;
            this.numTasks = numTasks;
            this.numVMs = numVMs;
            this.ccr = ccr;
            this.slr = slr;
            this.avu = avu;
            this.vf = vf;
            this.avgSatisfaction = avgSatisfaction;
            this.makespan = makespan;
        }

        @Override
        public String toString() {
            return String.format(Locale.US, "%s,%s,%d,%d,%.1f,%.4f,%.4f,%.6f,%.4f,%.4f",
                    experiment, workflow, numTasks, numVMs, ccr, slr, avu, vf, avgSatisfaction, makespan);
        }
    }

    public static void main(String[] args) {
        SeededRandom.initFromArgs(args);

        System.out.println("SM-CPTD Experiments");
        System.out.println("Runs: " + NUM_RUNS + " + " + WARMUP_RUNS + " warmup");

        boolean runExp1 = true;
        boolean runExp2 = true;
        String singleWorkflow = null;

        for (String arg : args) {
            if (arg.equals("--exp1")) {
                runExp1 = true;
                runExp2 = false;
            } else if (arg.equals("--exp2")) {
                runExp1 = false;
                runExp2 = true;
            } else if (arg.startsWith("--workflow=")) {
                singleWorkflow = arg.substring(11).trim().toLowerCase(Locale.ROOT);
            }
        }

        String[] workflowsToRun = singleWorkflow != null ? new String[] { singleWorkflow } : WORKFLOWS;

        try {
            if (runExp1) {
                runExperiment1_CCREffect(workflowsToRun);
            }

            if (runExp2) {
                runExperiment2_VMEffect(workflowsToRun);
            }

            saveResultsToCSV();
            saveResultsToJSON();
            printSummary();

        } catch (Exception e) {
            System.err.println("Error during execution: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Experiment 1: CCR effect on workflows
     */
    private static void runExperiment1_CCREffect(String[] workflows) {
        System.out.println("\nExperiment 1: CCR Effect");

        System.out.println("\nSmall (47-50 tasks, 5 VMs):");
        for (String workflow : workflows) {
            if (workflow.equals("cybershake")) {
                runCCRExperiment(new String[] { workflow }, 50, 5, "EXP1_SMALL");
            } else if (workflow.equals("epigenomics")) {
                runCCRExperiment(new String[] { workflow }, 47, 5, "EXP1_SMALL");
            } else {
                runCCRExperiment(new String[] { workflow }, 50, 5, "EXP1_SMALL");
            }
        }

        System.out.println("\nMedium (100 tasks, 10 VMs):");
        runCCRExperiment(workflows, 100, 10, "EXP1_MEDIUM");

        System.out.println("\nLarge (997-1000 tasks, 50 VMs):");
        for (String workflow : workflows) {
            int tasks = workflow.equals("epigenomics") ? 997 : 1000;
            runCCRExperiment(new String[] { workflow }, tasks, 50, "EXP1_LARGE");
        }
    }

    /**
     * Experiment 2: effect of VM count
     */
    private static void runExperiment2_VMEffect(String[] workflows) {
        System.out.println("\nExperiment 2: VM Count Effect");

        for (String workflow : workflows) {
            // Epigenomics has 997 tasks, the others have 1000
            int tasks = workflow.equals("epigenomics") ? 997 : 1000;
            System.out.println("\n" + workflow + " (" + tasks + " tasks, CCR=" + FIXED_CCR + ")");

            for (int numVMs : VM_COUNTS) {
                System.out.printf("   VM=%d: ", numVMs);

                try {
                    ExperimentResult result = runSingleExperiment(
                            workflow, tasks, numVMs, FIXED_CCR, "EXP2_VM", NUM_RUNS, WARMUP_RUNS);
                    if (result == null) {
                        System.out.println("Skipped");
                        continue;
                    }
                    results.add(result);
                    checkpointSave();
                    System.out.printf("SLR=%.4f, AVU=%.4f, VF=%.6f %n",
                            result.slr, result.avu, result.vf, NUM_RUNS);
                } catch (Exception e) {
                    System.out.println("Error: " + e.getMessage());
                }
            }
        }
    }

    /**
     * Run CCR experiments for a specific configuration. 
     */
    private static void runCCRExperiment(String[] workflows, int numTasks, int numVMs, String expName) {
        for (String workflow : workflows) {
            System.out.println("\nWorkflow: " + workflow + " (" + numTasks + " task, " + numVMs + " VM)");

            CCRAnalyzer ccrAnalyzer = new CCRAnalyzer(workflow, numTasks, numVMs, expName);

            for (double ccr : CCR_VALUES) {
                System.out.printf("   CCR=%.1f: ", ccr);

                try {
                    ExperimentResult result = runSingleExperimentWithAnalysis(
                            workflow, numTasks, numVMs, ccr, expName, NUM_RUNS, WARMUP_RUNS, ccrAnalyzer);
                    if (result == null) {
                        System.out.println(" Skipped");
                        continue;
                    }
                    results.add(result);
                    checkpointSave();
                    System.out.printf("SLR=%.4f, AVU=%.4f, VF=%.6f %n",
                            result.slr, result.avu, result.vf, NUM_RUNS);
                } catch (Exception e) {
                    System.out.println("Error: " + e.getMessage());
                }
            }
            
            try {
                String outputPath = "../results/ccr_sensitivity/" + workflow + "_" + 
                                   expName.toLowerCase() + "_analysis.json";
                ccrAnalyzer.saveToJSON(outputPath);
            } catch (Exception e) {
                System.err.println("   Failed to save CCR analysis: " + e.getMessage());
            }
        }
    }

    private static File ensureResultsDir() {
        File resultsDir = new File("../results");
        if (!resultsDir.exists()) {
            resultsDir.mkdirs();
        }
        return resultsDir;
    }

    /**
     * Incremental checkpoint save.
     */
    private static void checkpointSave() {
        saveResultsToCSV(false);
        saveResultsToJSON(false);
    }

    /**
     * Runs a single experiment across multiple runs and averages the metrics
     *
     * @param workflow   Workflow name
     * @param numTasks   Number of tasks
     * @param numVMs     Number of VMs
     * @param ccr        Communication to Computation Ratio
     * @param expName    Experiment label
     * @param numRuns    Number of runs to execute (default: 1)
     * @param warmupRuns Number of warmup runs to discard (default: 0)
     * @return Averaged result across runs
     */
    private static ExperimentResult runSingleExperiment(String workflow, int numTasks,
            int numVMs, double ccr, String expName,
            int numRuns, int warmupRuns)
            throws Exception {

        String workflowDir = findPegasusWorkflowDir(workflow.toLowerCase(), numTasks, numVMs);

        if (workflowDir == null) {
            System.out.println("Workflow not found for " + workflow + " " + numTasks + " tasks");
            return null;
        }

        // Store metrics for each run
        List<RunMetrics> runs = new ArrayList<>();
        int totalRuns = warmupRuns + numRuns;

        for (int runIdx = 0; runIdx < totalRuns; runIdx++) {
            boolean isWarmup = runIdx < warmupRuns;

            int seedRunIdx = runIdx;
            
            List<task> tasks = DataLoader.loadTasksFromCSV(workflowDir + "/dag.csv", workflowDir + "/task.csv", seedRunIdx);
            List<VM> vms = DataLoader.loadVMsFromCSV(workflowDir + "/processing_capacity.csv", seedRunIdx);
            DataLoader.loadBandwidthFromCSV(workflowDir + "/bandwidth.csv", vms, seedRunIdx);

            SMCPTD smcptd = new SMCPTD();
            smcptd.setInputData(tasks, vms);
            
            // Only generate Gantt charts for non-warmup runs
            if (isWarmup) {
                smcptd.setGanttChartSettings(false, workflow, ccr, 0);
            } else {
                int actualRunIdx = runIdx - warmupRuns;  // 0-based index for actual runs
                smcptd.setGanttChartSettings(true, workflow, ccr, actualRunIdx);
            }
            
            SMGT smgt = smcptd.getSMGT();

            Map<Integer, VM> vmMapping = new HashMap<>();
            for (VM vm : vms) {
                vmMapping.put(vm.getID(), vm);
            }

            Map<String, Double> commCosts = calculateCommunicationCostsForDCP(smgt, ccr);
            Map<Integer, List<Integer>> assignments = smcptd.executeSMCPTD(commCosts, vmMapping, ccr);


            // Compute metrics
            double makespan = smcptd.getMakespan();
            
            Set<Integer> criticalPath = smcptd.getCriticalPath();
            List<task> criticalPathTasks = new ArrayList<>();
            for (task t : tasks) {
                if (criticalPath.contains(t.getID())) {
                    criticalPathTasks.add(t);
                }
            }
            double slr = Metrics.SLR(makespan, criticalPathTasks, vmMapping);
            
            double avu = calculateAVU(smgt, assignments, makespan);
            double vf = calculateVF(smgt, assignments, makespan);
            double avgSatisfaction = calculateAvgSatisfaction(smgt, assignments, makespan);

            if (!isWarmup) {
                runs.add(new RunMetrics(slr, avu, vf, avgSatisfaction, makespan));
            }
        }

        double avgSLR = runs.stream().mapToDouble(r -> r.slr).average().orElse(0);
        double avgAVU = runs.stream().mapToDouble(r -> r.avu).average().orElse(0);
        double avgVF = runs.stream().mapToDouble(r -> r.vf).average().orElse(0);
        double avgSatisfaction = runs.stream().mapToDouble(r -> r.avgSatisfaction).average().orElse(0);
        double avgMakespan = runs.stream().mapToDouble(r -> r.makespan).average().orElse(0);

        List<task> tasksForCount = DataLoader.loadTasksFromCSV(workflowDir + "/dag.csv", workflowDir + "/task.csv");
        int actualTasks = tasksForCount.size();

        return new ExperimentResult(expName, workflow, actualTasks, numVMs, ccr, avgSLR, avgAVU, avgVF, avgSatisfaction, avgMakespan);
    }

    /**
     * Runs a single experiment with CCR analysis
     * 
     * This version captures data for CCR sensitivity analysis including:
     * - Communication costs
     * - Critical Path
     * - Task duplications
     * - Performance metrics
     */
    private static ExperimentResult runSingleExperimentWithAnalysis(
            String workflow, int numTasks, int numVMs, double ccr, String expName,
            int numRuns, int warmupRuns, CCRAnalyzer ccrAnalyzer)
            throws Exception {
        
        // Run the standard experiment
        ExperimentResult result = runSingleExperiment(workflow, numTasks, numVMs, ccr, expName, numRuns, warmupRuns);
        
        if (result == null) {
            return null;
        }
        
        // NEW: Capture additional data for CCR analysis (single run for analysis)
        try {
            String workflowDir = findPegasusWorkflowDir(workflow.toLowerCase(), numTasks, numVMs);
            if (workflowDir != null) {
                // Load data (using -1 for consistent seed in CCR analysis snapshot)
                // NOTE: This uses the default seed to ensure CCR analysis is consistent
                int seedRunIdx = -1; // Use same seed for CCR analysis snapshot
                List<task> tasks = DataLoader.loadTasksFromCSV(workflowDir + "/dag.csv", workflowDir + "/task.csv", seedRunIdx);
                List<VM> vms = DataLoader.loadVMsFromCSV(workflowDir + "/processing_capacity.csv", seedRunIdx);
                DataLoader.loadBandwidthFromCSV(workflowDir + "/bandwidth.csv", vms, seedRunIdx);
                
                SMCPTD smcptd = new SMCPTD();
                smcptd.setInputData(tasks, vms);
                smcptd.setGenerateGanttChart(false);
                SMGT smgt = smcptd.getSMGT();
                
                Map<Integer, VM> vmMapping = new HashMap<>();
                for (VM vm : vms) {
                    vmMapping.put(vm.getID(), vm);
                }
                
                Map<String, Double> commCosts = calculateCommunicationCostsForDCP(smgt, ccr);
                smcptd.executeSMCPTD(commCosts, vmMapping, ccr);
                
                Set<Integer> criticalPath = smcptd.getCriticalPath();
                
                Map<Integer, Set<Integer>> duplicatedTasks = new HashMap<>();
                LOTD lotd = smcptd.getLOTD();
                if (lotd != null) {
                    duplicatedTasks = lotd.getDuplicatedTasks();
                }
                
                ccrAnalyzer.captureSnapshot(
                    ccr,
                    commCosts,
                    criticalPath,
                    duplicatedTasks,
                    result.slr,
                    result.avu,
                    result.vf,
                    result.makespan
                );
            }
        } catch (Exception e) {
            System.err.println("       CCR analysis capture failed: " + e.getMessage());
        }
        
        return result;
    }

    /**
     * Helper class to hold metrics from one run
     */
    private static class RunMetrics {
        double slr, avu, vf, avgSatisfaction, makespan;

        RunMetrics(double slr, double avu, double vf, double avgSatisfaction, double makespan) {
            this.slr = slr;
            this.avu = avu;
            this.vf = vf;
            this.avgSatisfaction = avgSatisfaction;
            this.makespan = makespan;
        }
    }

    /**
     * Find workflow XML by task count.
     */
    private static String findWorkflowXML(String workflow, int targetTasks) {
        String workflowDir = "../workflow/" + workflow.toLowerCase();
        File dir = new File(workflowDir);

        if (!dir.exists() || !dir.isDirectory()) {
            return null;
        }

        String bestMatch = null;
        int bestDiff = Integer.MAX_VALUE;

        // Find the XML file closest to the requested task count
        for (File file : dir.listFiles()) {
            if (file.isFile() && file.getName().endsWith(".xml")) {
                String name = file.getName();
                // Formato: Workflow_123.xml
                int underscoreIdx = name.lastIndexOf("_");
                int dotIdx = name.lastIndexOf(".");

                if (underscoreIdx > 0 && dotIdx > underscoreIdx) {
                    String taskStr = name.substring(underscoreIdx + 1, dotIdx);
                    try {
                        int tasks = Integer.parseInt(taskStr);
                        int diff = Math.abs(tasks - targetTasks);
                        if (diff < bestDiff) {
                            bestDiff = diff;
                            bestMatch = file.getAbsolutePath();
                        }
                    } catch (NumberFormatException e) {
                    }
                }
            }
        }

        return bestMatch;
    }
    
    /**
     * Find and convert Pegasus workflow directory.
     */
    protected static String findPegasusWorkflowDir(String workflow, int targetTasks, int targetVMs) {
        String xmlFile = findWorkflowXML(workflow, targetTasks);
        if (xmlFile == null) {
            System.out.println("   Workflow XML not found for " + workflow + " " + targetTasks + " tasks");
            return null;
        }

        try {
            String outputDir = "../data/" + workflow.toLowerCase() + "_" + targetTasks;
            int vms = targetVMs > 0 ? targetVMs : 5;
            PegasusXMLParser.parseAndConvert(xmlFile, outputDir, vms);
            return outputDir;
        } catch (Exception e) {
            System.out.println("   XML conversion error: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Calculate communication costs for DCP (average across all VM pairs).
     */
    private static Map<String, Double> calculateCommunicationCostsForDCP(SMGT smgt, double ccr) {
        Map<String, Double> costs = new HashMap<>();
        List<VM> vms = smgt.getVMs();
        
        for (task t : smgt.getTasks()) {
            for (int succId : t.getSucc()) {
                String key = t.getID() + "_" + succId;
                task succ = Utility.getTaskById(succId, smgt.getTasks());
                double avgCost = Metrics.CommunicationCostCalculator.calculateAverage(t, succ, vms, ccr);
                costs.put(key, avgCost);
            }
        }
        
        return costs;
    }

    /**
     * Calculates AVU (Average VM Utilization). Delegates to Metrics.AVU.
     @param smgt SMGT instance containing tasks and VMs
     * @param assignments VM assignments (vmID → list of taskIDs)
     * @param makespan Total workflow execution time (should be from LOTD.taskAFT when available)
     * @return Average VM Utilization in range [0.0, 1.0] where 1.0 = 100% utilization
     * 
     * @implNote This method delegates actual calculation to {@link Metrics#AVU} after converting
     *           task IDs to task objects using optimized HashMap lookups. Performance logging
     *           is enabled for workflows with &gt;500 tasks or execution time &gt;10ms.
     * 
    * @see Metrics#AVU(Map, Map, double)
    * @see Metrics#VU(VM, List, double)
    * @see Metrics#ET(task, VM)
     * @see SMCPTD#calculateFinalMetrics for makespan calculation details
     */
    private static double calculateAVU(SMGT smgt, Map<Integer, List<Integer>> assignments, double makespan) {
        if (makespan <= 0) return 0;

        Map<Integer, task> taskMap = new HashMap<>();
        for (task t : smgt.getTasks()) {
            taskMap.put(t.getID(), t);
        }

        Map<Integer, VM> vmMap = new HashMap<>();
        for (VM v : smgt.getVMs()) {
            vmMap.put(v.getID(), v);
        }

        Set<Integer> assignedTaskIds = new HashSet<>();
        Map<Integer, List<task>> taskAssignments = new HashMap<>();
        
        for (Map.Entry<Integer, List<Integer>> entry : assignments.entrySet()) {
            int vmId = entry.getKey();
            List<task> tasks = new ArrayList<>();
            for (int taskId : entry.getValue()) {
                task t = taskMap.get(taskId);
                if (t != null) {
                    tasks.add(t);                } else if (t == null) {
                    System.err.println(" Warning: Task ID " + taskId + " not found in task map");
                }
            }
            taskAssignments.put(vmId, tasks);
        }

        return Metrics.AVU(vmMap, taskAssignments, makespan);
    }

    /**
     * Calculates VF (Variance of Fairness). Delegates to Metrics.VF.
     * @param smgt       SMGT instance containing all workflow tasks and available VMs
     * @param assignments Task-to-VM assignments (vmID → list of taskIDs assigned to that VM)
     * @param makespan   Total workflow execution time (UNUSED - kept for API consistency)
     * @return           Variance of Fairness (VF ≥ 0.0, lower = better fairness)
     * 
     * @implNote This method delegates the actual VF calculation to {@code Metrics.VF()},
     *           focusing on efficient data structure conversion from ID-based assignments
     *           to object-based assignments with O(n) complexity.
     * 
     * @see Metrics#VF(List, Map, Map, Map, String) for the underlying VF calculation
     * @see #calculateAVU(SMGT, Map, double) for AVU (VM utilization) metric calculation
     */
    private static double calculateVF(SMGT smgt, Map<Integer, List<Integer>> assignments, double makespan) {
        if (makespan <= 0) return 0;

        Map<Integer, task> taskMap = new HashMap<>();
        for (task t : smgt.getTasks()) {
            taskMap.put(t.getID(), t);
        }

        Map<Integer, VM> vmMap = new HashMap<>();
        for (VM v : smgt.getVMs()) {
            vmMap.put(v.getID(), v);
        }

        Set<Integer> assignedTaskIds = new HashSet<>();
        Map<Integer, List<task>> taskAssignments = new HashMap<>();
        
        for (Map.Entry<Integer, List<Integer>> entry : assignments.entrySet()) {
            int vmId = entry.getKey();
            List<task> tasks = new ArrayList<>();
            for (int taskId : entry.getValue()) {
                task t = taskMap.get(taskId);
                if (t != null ) {
                    tasks.add(t);
                } else if (t == null) {
                    System.err.println(" Warning: Task ID " + taskId + " not found in task map");
                }
            }
            taskAssignments.put(vmId, tasks);
        }

        double vf = Metrics.VF(smgt.getTasks(), vmMap, taskAssignments);
        return Double.isNaN(vf) || Double.isInfinite(vf) ? Double.NaN : vf;
    }

    /**
     * Calculates Average Satisfaction. Delegates to Metrics.AvgSatisfaction.
     * @param smgt       SMGT instance containing all workflow tasks and available VMs
     * @param assignments Task-to-VM assignments (vmID → list of taskIDs assigned to that VM)
     * @param makespan   Total workflow execution time (UNUSED - kept for API consistency)
     * @return           Average Satisfaction (≥ 1.0, or 0.0 if no valid tasks)
     * 
     * @see Metrics#AvgSatisfaction(List, Map, Map, String) for the underlying calculation
     * @see #calculateVF(SMGT, Map, double) for VF (variance of satisfaction) metric
     */
    private static double calculateAvgSatisfaction(SMGT smgt, Map<Integer, List<Integer>> assignments, double makespan) {
        if (makespan <= 0) return 0;

        Map<Integer, task> taskMap = new HashMap<>();
        for (task t : smgt.getTasks()) {
            taskMap.put(t.getID(), t);
        }

        Map<Integer, VM> vmMap = new HashMap<>();
        for (VM v : smgt.getVMs()) {
            vmMap.put(v.getID(), v);
        }

        Set<Integer> assignedTaskIds = new HashSet<>();
        Map<Integer, List<task>> taskAssignments = new HashMap<>();
        
        for (Map.Entry<Integer, List<Integer>> entry : assignments.entrySet()) {
            int vmId = entry.getKey();
            List<task> tasks = new ArrayList<>();
            for (int taskId : entry.getValue()) {
                task t = taskMap.get(taskId);
                if (t != null) {
                    tasks.add(t);
                } else {
                    System.err.println(" Warning: Task ID " + taskId + " not found in task map");
                }
            }
            taskAssignments.put(vmId, tasks);
        }

        double avgSat = Metrics.AvgSatisfaction(smgt.getTasks(), vmMap, taskAssignments);
        return Double.isNaN(avgSat) || Double.isInfinite(avgSat) ? Double.NaN : avgSat;
    }

    /**
     * Save results to CSV.
     */
    private static void saveResultsToCSV() {
        saveResultsToCSV(true);
    }

    private static void saveResultsToCSV(boolean verbose) {
        File outFile = new File(ensureResultsDir(), "experiments_results.csv");
        try (PrintWriter writer = new PrintWriter(outFile)) {
            writer.println("experiment,workflow,tasks,vms,ccr,slr,avu,vf,avg_satisfaction,makespan");
            for (ExperimentResult r : results) {
                if (r != null) {
                    writer.println(r.toString());
                }
            }
            if (verbose) {
                System.out.println("\nSaved: results/experiments_results.csv");
            }
        } catch (Exception e) {
            System.err.println("Save error CSV: " + e.getMessage());
        }
    }

    /**
     * Save results to JSON.
     */
    private static void saveResultsToJSON() {
        saveResultsToJSON(true);
    }

    private static void saveResultsToJSON(boolean verbose) {
        File outFile = new File(ensureResultsDir(), "experiments_results.json");
        try (PrintWriter writer = new PrintWriter(outFile)) {
            writer.println("{");
            writer.println("  \"experiments\": [");

            int totalToWrite = 0;
            for (ExperimentResult r : results) {
                if (r != null)
                    totalToWrite++;
            }

            int written = 0;
            for (ExperimentResult r : results) {
                if (r == null)
                    continue;
                writer.printf(Locale.US, "    {\"experiment\": \"%s\", \"workflow\": \"%s\", \"tasks\": %d, " +
                        "\"vms\": %d, \"ccr\": %.1f, \"slr\": %.4f, \"avu\": %.4f, " +
                        "\"vf\": %.6f, \"avg_satisfaction\": %.4f, \"makespan\": %.4f}",
                        r.experiment, r.workflow, r.numTasks, r.numVMs, r.ccr,
                        r.slr, r.avu, r.vf, r.avgSatisfaction, r.makespan);
                written++;
                if (written < totalToWrite) {
                    writer.println(",");
                } else {
                    writer.println();
                }
            }

            writer.println("  ]");
            writer.println("}");
            if (verbose) {
                System.out.println("Saved: results/experiments_results.json");
            }
        } catch (Exception e) {
            System.err.println("Save error JSON: " + e.getMessage());
        }
    }

    /**
     * Print results summary.
     */
    private static void printSummary() {
        System.out.println("\n" + "=".repeat(70));
        System.out.println("Summary");
        System.out.println("=".repeat(70));
        System.out.println("Total experiments: " + results.size());

        Map<String, List<ExperimentResult>> byExperiment = new HashMap<>();
        for (ExperimentResult r : results) {
            byExperiment.computeIfAbsent(r.experiment, k -> new ArrayList<>()).add(r);
        }

        for (String exp : byExperiment.keySet()) {
            List<ExperimentResult> expResults = byExperiment.get(exp);

            double avgSLR = expResults.stream().mapToDouble(r -> r.slr).average().orElse(0);
            double avgAVU = expResults.stream().mapToDouble(r -> r.avu).average().orElse(0);
            double avgVF = expResults.stream().mapToDouble(r -> r.vf).average().orElse(0);

            System.out.printf("\n%s (%d runs):%n", exp, expResults.size());
            System.out.printf("   Avg SLR: %.4f%n", avgSLR);
            System.out.printf("   Avg AVU: %.4f (%.1f%%)%n", avgAVU, avgAVU * 100);
            System.out.printf("   Avg VF:  %.6f%n", avgVF);
        }

        System.out.println("\nComplete");
    }

}